<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wisp - WebGPU Game Engine</title>
    <!-- Import map for npm packages via CDN -->
    <script type="importmap">
    {
        "imports": {
            "@bjorn3/browser_wasi_shim": "https://esm.sh/@bjorn3/browser_wasi_shim@0.3.0"
        }
    }
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            color: #fff;
        }
        #game-canvas { border: 2px solid #4a4a6a; border-radius: 4px; }
        #status { color: #888; margin-top: 16px; font-size: 14px; }
        #error { color: #ff6b6b; margin-top: 8px; font-size: 14px; }
        #controls { margin-top: 16px; color: #666; font-size: 12px; }
    </style>
</head>
<body>
    <canvas id="game-canvas" width="800" height="600"></canvas>
    <div id="status">Initializing...</div>
    <div id="error"></div>
    <div id="controls">Arrow keys / WASD: Move | Space: Action</div>

    <script type="module">
        const statusEl = document.getElementById('status');
        const errorEl = document.getElementById('error');

        // Input state (read by Swift via JSObject.global.inputState)
        window.inputState = {
            up: false, down: false, left: false, right: false,
            action: false, action2: false, pause: false,
            pointerDown: false, pointerX: 0, pointerY: 0,
            pointerJustPressed: false, pointerJustReleased: false
        };

        // Texture management
        window.loadedTextures = {};
        window.texturePathToId = {};  // path -> id mapping for deduplication
        let nextTextureId = 1;
        window.loadTexture = (path) => {
            // Return existing ID if already loaded/loading
            if (window.texturePathToId[path]) {
                return window.texturePathToId[path];
            }
            const id = nextTextureId++;
            window.texturePathToId[path] = id;
            fetch(path)
                .then(r => r.blob())
                .then(blob => createImageBitmap(blob))
                .then(bitmap => {
                    loadedTextures[id] = bitmap;
                    window.swiftExports?.wisp_onTextureLoaded?.(id, bitmap.width, bitmap.height);
                })
                .catch(e => console.error(`Texture load failed: ${path}`, e));
            return id;
        };

        // Audio
        window.playSound = (id, vol, loop) => console.log(`Play sound: ${id}`);
        window.stopSound = (id) => console.log(`Stop sound: ${id}`);

        // Input handling
        const canvas = document.getElementById('game-canvas');
        const keyMap = {
            'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right',
            'KeyW': 'up', 'KeyS': 'down', 'KeyA': 'left', 'KeyD': 'right',
            'Space': 'action', 'KeyZ': 'action', 'KeyX': 'action2'
        };

        document.addEventListener('keydown', e => {
            const k = keyMap[e.code];
            if (k) { inputState[k] = true; e.preventDefault(); }
        });
        document.addEventListener('keyup', e => {
            const k = keyMap[e.code];
            if (k) inputState[k] = false;
        });

        let wasPointerDown = false;
        canvas.addEventListener('mousedown', e => {
            inputState.pointerDown = true;
            inputState.pointerJustPressed = !wasPointerDown;
            const rect = canvas.getBoundingClientRect();
            inputState.pointerX = e.clientX - rect.left;
            inputState.pointerY = canvas.height - (e.clientY - rect.top);
        });
        canvas.addEventListener('mouseup', () => {
            inputState.pointerJustReleased = wasPointerDown;
            inputState.pointerDown = false;
        });
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            inputState.pointerX = e.clientX - rect.left;
            inputState.pointerY = canvas.height - (e.clientY - rect.top);
        });

        // Callbacks from Swift
        window.onWispReady = () => {
            statusEl.textContent = 'Running';
            startGameLoop();
        };
        window.onWispError = msg => errorEl.textContent = msg;

        // Game loop
        let lastTime = 0;
        function startGameLoop() {
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
        function gameLoop(t) {
            const dt = (t - lastTime) / 1000;
            lastTime = t;
            wasPointerDown = inputState.pointerDown;
            window.swiftExports?.wisp_tick?.(dt);
            inputState.pointerJustPressed = false;
            inputState.pointerJustReleased = false;
            requestAnimationFrame(gameLoop);
        }

        // Load WASM via PackageToJS generated files
        async function init() {
            if (!navigator.gpu) {
                errorEl.textContent = 'WebGPU not supported (use Chrome/Edge 113+)';
                return;
            }
            statusEl.textContent = 'Loading...';
            try {
                // Import from PackageToJS output
                const { instantiate } = await import('./WispExample/instantiate.js');
                const { defaultBrowserSetup } = await import('./WispExample/platforms/browser.js');

                // Load WASM module
                const wasmResponse = fetch('./WispExample/WispExample.wasm');

                // Set up browser environment
                const options = await defaultBrowserSetup({
                    module: wasmResponse,
                });

                // Instantiate
                const { swift } = await instantiate(options);

                // Store exports for use in game loop
                window.swiftExports = swift.instance.exports;

                statusEl.textContent = 'Initializing WebGPU...';

                // wisp_initAsync is called automatically by main()
                // The game loop will start when onWispReady is called
            } catch (e) {
                errorEl.textContent = `Error: ${e.message}`;
                console.error(e);
            }
        }

        init();
    </script>
</body>
</html>
